<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FTLãŠã¿ã‚„ã’é…å¸ƒâ˜†ã‚ã¿ã ãã˜</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        @import url('https://fonts.googleapis.com/css2?family=M+PLUS+Rounded+1c:wght@400;700;900&display=swap');
        
        body {
            font-family: 'M PLUS Rounded 1c', sans-serif;
            background-color: #fff0f5; /* è–„ã„ãƒ”ãƒ³ã‚¯ */
            background-image: radial-gradient(#fbcfe8 2px, transparent 2px);
            background-size: 20px 20px;
            color: #5c4b51;
        }

        .canvas-container {
            position: relative;
            width: 100%;
            overflow-x: auto;
            background: rgba(255, 255, 255, 0.9);
            border: 4px solid #f9a8d4;
            border-radius: 1.5rem;
            box-shadow: 0 10px 15px -3px rgba(249, 168, 212, 0.3);
        }

        canvas {
            cursor: pointer;
            touch-action: none;
        }

        /* ã·ã‚‹ã‚“ã¨ã—ãŸãƒœã‚¿ãƒ³ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
        .btn-pop {
            transition: all 0.2s cubic-bezier(0.34, 1.56, 0.64, 1);
        }
        .btn-pop:active {
            transform: scale(0.95);
        }
        .btn-pop:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .animate-fade-in {
            animation: fadeIn 0.5s ease-out forwards;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }

        .custom-scrollbar::-webkit-scrollbar {
            width: 8px;
        }
        .custom-scrollbar::-webkit-scrollbar-track {
            background: #fff0f5;
            border-radius: 4px;
        }
        .custom-scrollbar::-webkit-scrollbar-thumb {
            background: #f9a8d4;
            border-radius: 4px;
        }
    </style>
</head>
<body class="min-h-screen flex flex-col items-center py-8 px-4">

    <header class="mb-8 text-center animate-fade-in">
        <h1 class="text-4xl md:text-5xl font-black text-pink-500 mb-2 drop-shadow-sm tracking-wide">
            <i class="fas fa-star text-yellow-400 mr-2 rotate-12"></i>ã‚ã¿ã ãã˜<i class="fas fa-heart text-red-400 ml-2 -rotate-12"></i>
        </h1>
        <p class="text-gray-500 font-bold bg-white/80 inline-block px-4 py-1 rounded-full shadow-sm">
            ã‚ãã‚ããƒ‰ã‚­ãƒ‰ã‚­ã®æŠ½é¸ã‚¿ã‚¤ãƒ ï¼
        </p>
    </header>

    <main class="w-full max-w-4xl space-y-8">
        
        <!-- è¨­å®šã‚¨ãƒªã‚¢ -->
        <div id="setup-panel" class="bg-white/90 backdrop-blur-sm p-8 rounded-[2rem] shadow-xl border-4 border-pink-200 animate-fade-in">
            
            <!-- ä¸Šæ®µï¼šäººæ•°è¨­å®š -->
            <div class="flex flex-col items-center justify-center mb-8 pb-6 border-b-2 border-dashed border-pink-200">
                <label class="font-bold text-xl text-gray-600 mb-4 flex items-center">
                    <span class="bg-blue-100 text-blue-500 rounded-full w-8 h-8 flex items-center justify-center mr-2"><i class="fas fa-users"></i></span>
                    å‚åŠ äººæ•°ã‚’æ±ºã‚ã¦ã­
                </label>
                <div class="flex items-center bg-pink-50 rounded-2xl p-2 shadow-inner gap-4 border-2 border-pink-100">
                    <button onclick="changeCount(-1)" class="btn-pop w-12 h-12 rounded-xl bg-white text-pink-500 font-black text-2xl shadow-sm border border-pink-100">-</button>
                    <span id="count-display" class="w-20 text-center font-black text-4xl text-gray-700">4</span>
                    <button onclick="changeCount(1)" class="btn-pop w-12 h-12 rounded-xl bg-white text-pink-500 font-black text-2xl shadow-sm border border-pink-100">+</button>
                </div>
            </div>

            <!-- ä¸­æ®µï¼šå•†å“è¨­å®š -->
            <div class="bg-yellow-50 p-6 rounded-[1.5rem] mb-8 border-2 border-yellow-200 relative">
                <div class="absolute -top-4 left-6 bg-yellow-400 text-white font-bold px-4 py-1 rounded-full text-sm shadow-md transform -rotate-2">
                    <i class="fas fa-gift mr-1"></i> å•†å“ãƒªã‚¹ãƒˆ
                </div>

                <!-- è¿½åŠ ãƒ•ã‚©ãƒ¼ãƒ  -->
                <div class="flex flex-wrap gap-3 mb-4 items-end mt-2">
                    <div class="flex-1 min-w-[140px]">
                        <label class="text-xs text-yellow-700 font-bold ml-2">ãªã«ãŒå½“ãŸã‚‹ï¼Ÿ</label>
                        <input type="text" id="bulk-name" placeholder="ä¾‹: ğŸ° ã‚±ãƒ¼ã‚­" class="w-full border-2 border-yellow-200 rounded-2xl px-4 py-3 focus:outline-none focus:border-yellow-400 focus:ring-4 focus:ring-yellow-100 bg-white font-bold text-gray-700 placeholder-yellow-200 transition-all">
                    </div>
                    <div class="w-24">
                        <label class="text-xs text-yellow-700 font-bold ml-2">ã„ãã¤ï¼Ÿ</label>
                        <input type="number" id="bulk-count" value="1" min="1" class="w-full border-2 border-yellow-200 rounded-2xl px-3 py-3 focus:outline-none focus:border-yellow-400 focus:ring-4 focus:ring-yellow-100 text-center bg-white font-bold text-gray-700">
                    </div>
                    <button onclick="addBulkItem()" class="btn-pop bg-yellow-400 text-white font-bold px-6 py-3 rounded-2xl shadow-md h-[52px] border-b-4 border-yellow-500 active:border-b-0 active:translate-y-1">
                        <i class="fas fa-plus"></i> è¿½åŠ 
                    </button>
                </div>

                <!-- ãƒªã‚¹ãƒˆè¡¨ç¤º -->
                <div class="bg-white rounded-2xl p-4 shadow-inner border border-yellow-100 min-h-[100px] max-h-[300px] overflow-y-auto custom-scrollbar">
                    <ul id="bulk-list" class="space-y-2">
                        <li class="text-gray-300 text-center py-6 flex flex-col items-center font-bold">
                            <i class="fas fa-magic mb-2 text-yellow-200 text-3xl"></i>
                            <span>ã“ã“ã«å•†å“ã‚’è¿½åŠ ã—ã¦ã­ï¼</span>
                        </li>
                    </ul>
                </div>
                
                <p class="text-right text-xs text-yellow-600 font-bold mt-2 mr-2">
                    â€»å…¥åŠ›ãŒäººæ•°ã‚ˆã‚Šå°‘ãªã„åˆ†ã¯ã€Œâ˜…ã€ã«ãªã‚Šã¾ã™
                </p>
            </div>

            <!-- ä½œæˆãƒœã‚¿ãƒ³ -->
            <div class="text-center">
                <button onclick="generateAmida()" class="btn-pop w-full md:w-2/3 px-12 py-5 bg-gradient-to-r from-pink-400 to-rose-400 text-white text-xl rounded-full font-black shadow-lg shadow-pink-200 border-b-4 border-rose-500 active:border-b-0 active:translate-y-1 flex items-center justify-center mx-auto tracking-wider">
                    <i class="fas fa-wand-magic-sparkles mr-2"></i> ã‚¹ã‚¿ãƒ¼ãƒˆï¼
                </button>
            </div>
        </div>

        <!-- ã‚ã¿ã ãã˜è¡¨ç¤ºã‚¨ãƒªã‚¢ -->
        <div id="game-panel" class="hidden space-y-6 animate-fade-in">
            
            <div class="flex flex-wrap justify-between items-center bg-white/80 backdrop-blur p-4 rounded-2xl shadow-sm border-2 border-pink-100 gap-3">
                <button onclick="resetView()" class="text-pink-400 hover:text-pink-600 font-bold px-3 py-1 btn-pop">
                    <i class="fas fa-chevron-left mr-1"></i> ã‚‚ã©ã‚‹
                </button>
                <div class="flex gap-3">
                     <button onclick="resetPaths()" class="px-5 py-2 bg-gray-100 text-gray-600 rounded-xl font-bold hover:bg-gray-200 transition btn-pop text-sm">
                        <i class="fas fa-undo mr-1"></i> ã‚‚ã†ä¸€å›
                    </button>
                    <button onclick="revealAll()" class="px-5 py-2 bg-blue-400 text-white rounded-xl font-bold hover:bg-blue-500 transition shadow-md shadow-blue-200 btn-pop text-sm">
                        <i class="fas fa-eye mr-1"></i> å…¨éƒ¨ã¿ã‚‹
                    </button>
                </div>
            </div>

            <!-- å•†å“ãƒ©ã‚¤ãƒ³ãƒŠãƒƒãƒ—è¡¨ç¤º -->
            <div id="prize-lineup" class="bg-yellow-100 border-2 border-yellow-300 p-4 rounded-2xl text-center shadow-sm relative overflow-hidden">
                <i class="fas fa-gift absolute -right-4 -bottom-4 text-6xl text-yellow-200/50 rotate-12"></i>
                <div class="relative z-10">
                    <span class="font-black text-yellow-700 mr-2 bg-white px-3 py-1 rounded-full text-sm inline-block mb-1">ä»Šå›ã®ãƒ©ã‚¤ãƒ³ãƒŠãƒƒãƒ—</span>
                    <div id="lineup-text" class="text-gray-700 font-bold mt-1 text-lg"></div>
                </div>
            </div>

            <div class="canvas-container p-6 overflow-x-auto text-center bg-white">
                <canvas id="amidaCanvas"></canvas>
            </div>

            <!-- çµæœè¡¨ç¤ºã‚¨ãƒªã‚¢ -->
            <div id="result-message" class="hidden bg-white p-8 rounded-[2rem] shadow-xl border-4 border-pink-300 animate-fade-in text-center relative overflow-hidden">
                <div class="absolute top-0 left-0 w-full h-2 bg-gradient-to-r from-pink-300 via-yellow-300 to-blue-300"></div>
                <p id="result-text" class="text-2xl text-gray-700 font-bold relative z-10"></p>
                <div class="mt-4 text-6xl animate-bounce">ğŸ‰</div>
            </div>
        </div>

    </main>

    <script>
        // --- è¨­å®šå€¤ ---
        const MIN_COUNT = 2;
        const MAX_COUNT = 30; 
        let currentCount = 4;
        
        // --- ãƒ‡ãƒ¼ã‚¿ ---
        let names = []; 
        let results = [];
        let horizontalLines = []; 
        
        let bulkItems = [];

        // --- ã‚­ãƒ£ãƒ³ãƒã‚¹é–¢é€£ ---
        const canvas = document.getElementById('amidaCanvas');
        const ctx = canvas.getContext('2d');
        let canvasWidth, canvasHeight;
        const headerHeight = 70; // å°‘ã—åºƒã’ã‚‹
        const footerHeight = 70; 
        const paddingX = 40;
        
        // ãƒ‘ã‚¹ãƒ†ãƒ«ã‚«ãƒ©ãƒ¼ãƒ‘ãƒ¬ãƒƒãƒˆ
        const colors = [
            '#ff99c8', '#fcf6bd', '#d0f4de', '#a9def9', '#e4c1f9', 
            '#ffadad', '#ffd6a5', '#fdffb6', '#caffbf', '#9bf6ff'
        ];
        // ç·šã®è‰²ã¯æ¿ƒã„ã‚ã«ã™ã‚‹
        const lineColors = [
            '#ef4444', '#f97316', '#f59e0b', '#84cc16', '#10b981', 
            '#06b6d4', '#3b82f6', '#8b5cf6', '#d946ef', '#f43f5e'
        ];

        // çŠ¶æ…‹ç®¡ç†
        let paths = []; 
        let isAnimating = false;
        let revealed = new Array(MAX_COUNT).fill(false); 
        let revealedResults = new Array(MAX_COUNT).fill(false); 

        // --- åˆæœŸåŒ– ---
        function init() {
            updateDisplays();
            updateBulkList();
        }

        function updateDisplays() {
            document.getElementById('count-display').textContent = currentCount;
        }
        
        function changeCount(delta) {
            const newCount = currentCount + delta;
            if (newCount >= MIN_COUNT && newCount <= MAX_COUNT) {
                currentCount = newCount;
                updateDisplays();
            }
        }

        // --- ä¸€æ‹¬è¨­å®šãƒ„ãƒ¼ãƒ«ç”¨ãƒ­ã‚¸ãƒƒã‚¯ ---

        function addBulkItem() {
            const nameInput = document.getElementById('bulk-name');
            const countInput = document.getElementById('bulk-count');
            
            const name = nameInput.value.trim();
            const count = parseInt(countInput.value);

            if (!name) return;
            if (count < 1) return;

            bulkItems.push({ name, count });
            
            nameInput.value = '';
            countInput.value = 1;
            nameInput.focus();

            updateBulkList();
        }

        function removeBulkItem(index) {
            bulkItems.splice(index, 1);
            updateBulkList();
        }

        function updateBulkList() {
            const listEl = document.getElementById('bulk-list');
            listEl.innerHTML = '';

            if (bulkItems.length === 0) {
                listEl.innerHTML = `
                    <li class="text-gray-300 text-center py-6 flex flex-col items-center font-bold">
                        <i class="fas fa-magic mb-2 text-yellow-200 text-3xl"></i>
                        <span>ã“ã“ã«å•†å“ã‚’è¿½åŠ ã—ã¦ã­ï¼</span>
                    </li>`;
                return;
            }

            bulkItems.forEach((item, index) => {
                const li = document.createElement('li');
                li.className = 'flex justify-between items-center bg-yellow-50 px-4 py-3 rounded-xl border border-yellow-200 shadow-sm animate-fade-in';
                li.innerHTML = `
                    <div class="flex items-center gap-3">
                        <span class="w-10 h-10 rounded-full bg-white border-2 border-yellow-200 flex items-center justify-center text-yellow-500 font-bold text-lg shadow-sm"><i class="fas fa-gift"></i></span>
                        <span class="font-bold text-gray-700 text-lg">${item.name}</span>
                        <span class="text-yellow-600 text-xs font-bold bg-yellow-100 px-3 py-1 rounded-full border border-yellow-200">Ã— ${item.count}</span>
                    </div>
                    <button onclick="removeBulkItem(${index})" class="text-red-400 hover:text-red-500 w-8 h-8 flex items-center justify-center rounded-full hover:bg-red-50 transition"><i class="fas fa-times"></i></button>
                `;
                listEl.appendChild(li);
            });
        }

        // --- ã‚ã¿ã ãã˜ç”Ÿæˆãƒ­ã‚¸ãƒƒã‚¯ ---

        function generateAmida() {
            // ã‚´ãƒ¼ãƒ«(results)ã‚’ç”Ÿæˆ
            results = [];

            // è¨­å®šæ¸ˆã¿ã‚¢ã‚¤ãƒ†ãƒ ã‚’å±•é–‹
            bulkItems.forEach(item => {
                for(let i=0; i<item.count; i++) {
                    results.push(item.name);
                }
            });

            // è¶³ã‚Šãªã„åˆ†ã¯å¯æ„›ã„è¨˜å·ã§åŸ‹ã‚ã‚‹ (ç©ºç™½æ‰±ã„)
            const currentLen = results.length;
            if (currentLen < currentCount) {
                for(let i=currentLen; i<currentCount; i++) {
                    results.push("â˜…"); // ã‚­ãƒ©ã‚­ãƒ©
                }
            } else if (currentLen > currentCount) {
                results.sort(() => 0.5 - Math.random());
                results = results.slice(0, currentCount);
            }

            // æœ€å¾Œã«é…ç½®ã‚’ã‚·ãƒ£ãƒƒãƒ•ãƒ«
            results.sort(() => 0.5 - Math.random());
            
            // ãƒ©ã‚¤ãƒ³ãƒŠãƒƒãƒ—é›†è¨ˆ
            const summary = {};
            let hasItem = false;
            results.forEach(r => {
                if (r !== "â˜…") {
                    summary[r] = (summary[r] || 0) + 1;
                    hasItem = true;
                }
            });
            
            let summaryText;
            if (!hasItem) {
                summaryText = "ï¼ˆå•†å“ãªã—...ï¼Ÿï¼‰";
            } else {
                summaryText = Object.entries(summary)
                    .map(([name, count]) => `${name}Ã—${count}`)
                    .join(' / ');
            }
            document.getElementById('lineup-text').textContent = summaryText;

            // åå‰ï¼ˆä¸Šï¼‰ã®æº–å‚™
            names = [];
            for(let i=0; i<currentCount; i++) {
                names[i] = `${i+1}`;
            }

            // æ¨ªç·šã‚’ç”Ÿæˆ
            horizontalLines = [];
            const segments = 12; 
            
            for (let s = 0; s < segments; s++) {
                const gaps = currentCount - 1;
                let candidates = [];
                for(let g=0; g<gaps; g++) candidates.push(g);
                candidates.sort(() => 0.5 - Math.random());
                
                let used = new Array(gaps).fill(false);
                
                for(let g of candidates) {
                    if(used[g]) continue;
                    if(g > 0 && used[g-1]) continue;
                    if(g < gaps-1 && used[g+1]) continue;

                    if(Math.random() > 0.3) {
                        const segmentHeight = 0.8 / segments;
                        const baseY = 0.1 + (s * segmentHeight);
                        horizontalLines.push({
                            col: g,
                            y: baseY + (Math.random() * 0.02)
                        });
                        used[g] = true;
                    }
                }
            }
            horizontalLines.sort((a, b) => a.y - b.y);

            document.getElementById('setup-panel').classList.add('hidden');
            document.getElementById('game-panel').classList.remove('hidden');
            document.querySelector('header').classList.add('hidden'); 
            
            revealed = new Array(currentCount).fill(false);
            revealedResults = new Array(currentCount).fill(false);
            paths = [];
            isAnimating = false;
            document.getElementById('result-message').classList.add('hidden');

            setTimeout(resizeCanvas, 50);
        }

        function resetView() {
            document.getElementById('game-panel').classList.add('hidden');
            document.getElementById('setup-panel').classList.remove('hidden');
            document.querySelector('header').classList.remove('hidden');
        }

        function resetPaths() {
            if(isAnimating) return;
            revealed = new Array(currentCount).fill(false);
            revealedResults = new Array(currentCount).fill(false);
            paths = [];
            document.getElementById('result-message').classList.add('hidden');
            drawBoard();
        }

        // --- æç”»å‡¦ç† ---

        function resizeCanvas() {
            const container = document.querySelector('.canvas-container');
            const colWidth = Math.max(60, Math.min(100, (container.clientWidth - paddingX * 2) / (currentCount - 1)));
            
            canvasWidth = Math.max(container.clientWidth, (currentCount - 1) * colWidth + paddingX * 2);
            canvasHeight = Math.max(400, window.innerHeight * 0.6); 

            const dpr = window.devicePixelRatio || 1;
            canvas.width = canvasWidth * dpr;
            canvas.height = canvasHeight * dpr;
            canvas.style.width = `${canvasWidth}px`;
            canvas.style.height = `${canvasHeight}px`;
            ctx.scale(dpr, dpr);

            drawBoard();
        }

        function getColX(index) {
            const totalContentWidth = (currentCount - 1) * getColSpacing();
            const startX = (canvasWidth - totalContentWidth) / 2;
            return startX + index * getColSpacing();
        }

        function getColSpacing() {
            return Math.min(120, (canvasWidth - paddingX * 2) / Math.max(1, currentCount - 1));
        }

        function drawBoard() {
            ctx.clearRect(0, 0, canvasWidth, canvasHeight);
            
            const lineTop = headerHeight + 20;
            const lineBottom = canvasHeight - footerHeight - 20;
            const lineHeight = lineBottom - lineTop;

            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';

            // 1. ãƒ†ã‚­ã‚¹ãƒˆã¨ãƒœãƒƒã‚¯ã‚¹æç”»
            ctx.font = 'bold 16px "M PLUS Rounded 1c"';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            for (let i = 0; i < currentCount; i++) {
                const x = getColX(i);
                const colorIdx = i % colors.length;
                const bgColor = colors[colorIdx];
                const lineColor = lineColors[colorIdx];
                
                // --- åå‰ (ä¸Šï¼šè‡ªå‹•æ¡ç•ª) ---
                // ãƒãƒƒãƒ—ãªä¸¸
                ctx.beginPath();
                ctx.arc(x, 40, 24, 0, Math.PI * 2);
                ctx.fillStyle = revealed[i] ? '#e5e7eb' : bgColor;
                ctx.fill();
                ctx.lineWidth = 3;
                ctx.strokeStyle = revealed[i] ? '#d1d5db' : '#fff';
                ctx.stroke();
                
                // ç•ªå·è¡¨ç¤º
                ctx.fillStyle = revealed[i] ? '#9ca3af' : '#78350f'; // èŒ¶è‰²ã£ã½ã„æ–‡å­—
                ctx.fillText(`${i+1}`, x, 40);
                
                // ã‚¹ã‚¿ãƒ¼ãƒˆåœ°ç‚¹ã®å°ã•ãªä¸¸
                ctx.beginPath();
                ctx.arc(x, lineTop, 6, 0, Math.PI * 2);
                ctx.fillStyle = revealed[i] ? '#d1d5db' : lineColor;
                ctx.fill();

                // --- çµæœ (ä¸‹) ---
                const isRevealed = revealedResults[i];

                if (isRevealed) {
                    ctx.fillStyle = '#fff';
                    ctx.shadowColor = "rgba(0,0,0,0.1)";
                    ctx.shadowBlur = 4;
                    ctx.shadowOffsetY = 2;
                } else {
                    ctx.fillStyle = '#fce7f3'; // ãƒ”ãƒ³ã‚¯èƒŒæ™¯
                    ctx.shadowColor = "transparent";
                }
                
                // ä¸‹ã®ãƒœãƒƒã‚¯ã‚¹
                ctx.strokeStyle = isRevealed ? '#f9a8d4' : '#fbcfe8';
                ctx.lineWidth = 2;
                
                ctx.beginPath();
                ctx.roundRect(x - 30, lineBottom + 10, 60, footerHeight, 12);
                ctx.fill();
                ctx.shadowColor = "transparent"; // Reset shadow for stroke
                ctx.stroke();

                if (isRevealed) {
                    ctx.fillStyle = '#db2777'; // æ¿ƒã„ãƒ”ãƒ³ã‚¯
                    const result = results[i];
                    if (result.length > 5) ctx.font = 'bold 12px "M PLUS Rounded 1c"';
                    else ctx.font = 'bold 14px "M PLUS Rounded 1c"';
                    ctx.fillText(result.substring(0, 8), x, lineBottom + 10 + footerHeight/2);
                } else {
                    ctx.fillStyle = '#f472b6';
                    ctx.font = 'bold 24px "M PLUS Rounded 1c"';
                    ctx.fillText("?", x, lineBottom + 10 + footerHeight/2);
                }
            }

            // 2. ç¸¦ç·šæç”»
            ctx.lineWidth = 4;
            ctx.strokeStyle = '#fce7f3'; // ã¨ã¦ã‚‚è–„ã„ãƒ”ãƒ³ã‚¯
            for (let i = 0; i < currentCount; i++) {
                const x = getColX(i);
                ctx.beginPath();
                ctx.moveTo(x, lineTop);
                ctx.lineTo(x, lineBottom);
                ctx.stroke();
            }

            // 3. æ¨ªç·šæç”»
            for (let line of horizontalLines) {
                const x1 = getColX(line.col);
                const x2 = getColX(line.col + 1);
                const y = lineTop + (line.y * lineHeight);

                ctx.beginPath();
                ctx.moveTo(x1, y);
                ctx.lineTo(x2, y);
                ctx.stroke();
            }

            // 4. å®Œäº†ã—ãŸãƒ‘ã‚¹ã®æç”»
            paths.forEach(p => {
                drawPathLine(p.coords, lineColors[p.startIndex % lineColors.length]);
            });
        }

        function calculatePath(startIndex) {
            let col = startIndex;
            let currentY = 0;
            const coords = [];
            
            const lineTop = headerHeight + 20;
            const lineBottom = canvasHeight - footerHeight - 20;
            const lineHeight = lineBottom - lineTop;

            coords.push({ x: getColX(col), y: lineTop });

            for (let i = 0; i < horizontalLines.length; i++) {
                const line = horizontalLines[i];
                
                if (line.y > currentY) {
                    if (line.col === col - 1) {
                        const yPixel = lineTop + (line.y * lineHeight);
                        coords.push({ x: getColX(col), y: yPixel });
                        col = col - 1;
                        coords.push({ x: getColX(col), y: yPixel });
                        currentY = line.y;
                    }
                    else if (line.col === col) {
                        const yPixel = lineTop + (line.y * lineHeight);
                        coords.push({ x: getColX(col), y: yPixel });
                        col = col + 1;
                        coords.push({ x: getColX(col), y: yPixel });
                        currentY = line.y;
                    }
                }
            }
            coords.push({ x: getColX(col), y: lineBottom });

            return {
                startIndex: startIndex,
                endIndex: col,
                coords: coords
            };
        }

        function drawPathLine(coords, color) {
            ctx.lineWidth = 6;
            ctx.strokeStyle = color;
            ctx.lineCap = 'round';
            ctx.lineJoin = 'round';
            ctx.shadowBlur = 0;
            
            ctx.beginPath();
            if(coords.length > 0) ctx.moveTo(coords[0].x, coords[0].y);
            
            for (let i = 1; i < coords.length; i++) {
                ctx.lineTo(coords[i].x, coords[i].y);
            }
            ctx.stroke();
        }

        function animateSinglePath(pathData, onComplete) {
            isAnimating = true;
            
            let totalLength = 0;
            const segments = [];
            for(let i=0; i<pathData.coords.length-1; i++) {
                const dx = pathData.coords[i+1].x - pathData.coords[i].x;
                const dy = pathData.coords[i+1].y - pathData.coords[i].y;
                const dist = Math.sqrt(dx*dx + dy*dy);
                segments.push({
                    start: pathData.coords[i],
                    end: pathData.coords[i+1],
                    length: dist
                });
                totalLength += dist;
            }

            let currentDist = 0;
            const duration = 4000; 
            const startTime = performance.now();
            const color = lineColors[pathData.startIndex % lineColors.length];
            
            function loop(now) {
                const elapsed = now - startTime;
                currentDist = (elapsed / duration) * totalLength;
                
                if(currentDist > totalLength) currentDist = totalLength;

                drawBoard(); 
                
                ctx.lineWidth = 6;
                ctx.strokeStyle = color;
                ctx.shadowBlur = 4;
                ctx.shadowColor = color;
                ctx.beginPath();
                ctx.moveTo(segments[0].start.x, segments[0].start.y);

                let distRem = currentDist;
                for(let seg of segments) {
                    if(distRem <= 0) break;
                    if(distRem >= seg.length) {
                        ctx.lineTo(seg.end.x, seg.end.y);
                        distRem -= seg.length;
                    } else {
                        const ratio = distRem / seg.length;
                        const mx = seg.start.x + (seg.end.x - seg.start.x) * ratio;
                        const my = seg.start.y + (seg.end.y - seg.start.y) * ratio;
                        ctx.lineTo(mx, my);
                        distRem = 0;
                    }
                }
                ctx.stroke();
                ctx.shadowBlur = 0;

                // å…ˆé ­ã«ã‚­ãƒ©ã‚­ãƒ©
                if (currentDist > 0 && currentDist < totalLength) {
                    let headX, headY;
                    let distRem2 = currentDist;
                    for(let seg of segments) {
                        if (distRem2 <= seg.length) {
                            const ratio = distRem2 / seg.length;
                            headX = seg.start.x + (seg.end.x - seg.start.x) * ratio;
                            headY = seg.start.y + (seg.end.y - seg.start.y) * ratio;
                            break;
                        }
                        distRem2 -= seg.length;
                    }
                    if(headX !== undefined) {
                        ctx.beginPath();
                        ctx.arc(headX, headY, 6, 0, Math.PI*2);
                        ctx.fillStyle = color;
                        ctx.fill();
                        ctx.fillStyle = 'white';
                        ctx.beginPath();
                        ctx.arc(headX, headY, 3, 0, Math.PI*2);
                        ctx.fill();
                    }
                }

                if (currentDist < totalLength) {
                    requestAnimationFrame(loop);
                } else {
                    isAnimating = false;
                    paths.push(pathData);
                    revealedResults[pathData.endIndex] = true;
                    drawBoard();
                    showResult(pathData);
                    if(onComplete) onComplete();
                }
            }
            requestAnimationFrame(loop);
        }

        function showResult(pathData) {
            const startName = names[pathData.startIndex];
            const endResult = results[pathData.endIndex];
            
            const msgBox = document.getElementById('result-message');
            const msgText = document.getElementById('result-text');
            
            msgText.innerHTML = `
                <div class="mb-2 text-pink-400 text-sm font-bold">ğŸ‰ çµæœç™ºè¡¨ ğŸ‰</div>
                <div class="text-xl mb-3">
                    <span class="font-black text-blue-500 text-3xl">${startName}</span>ç•ª ã¯...
                </div>
                <div class="text-4xl font-black text-pink-500 drop-shadow-sm animate-pulse">${endResult}</div>
            `;
            msgBox.classList.remove('hidden');
            msgBox.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        canvas.addEventListener('click', (e) => {
            if (isAnimating) return;
            const rect = canvas.getBoundingClientRect();
            const clickX = e.clientX - rect.left;
            const clickY = e.clientY - rect.top;

            // ãƒ˜ãƒƒãƒ€ãƒ¼åˆ¤å®šï¼ˆå°‘ã—åºƒã’ãŸï¼‰
            if (clickY < headerHeight + 60) {
                let clickedCol = -1;
                for(let i=0; i<currentCount; i++) {
                    const cx = getColX(i);
                    if (Math.abs(clickX - cx) < 40) {
                        clickedCol = i;
                        break;
                    }
                }
                if (clickedCol !== -1 && !revealed[clickedCol]) {
                    revealed[clickedCol] = true;
                    drawBoard();
                    const pathData = calculatePath(clickedCol);
                    animateSinglePath(pathData);
                }
            }
        });

        async function revealAll() {
            if(isAnimating) return;
            
            const unrevealedIndices = [];
            for(let i=0; i<currentCount; i++) {
                if(!revealed[i]) unrevealedIndices.push(i);
            }
            
            if(unrevealedIndices.length === 0) return;

            for(let i of unrevealedIndices) {
                revealed[i] = true;
                const path = calculatePath(i);
                paths.push(path);
                revealedResults[path.endIndex] = true; 
            }
            
            drawBoard();
            
            const msgBox = document.getElementById('result-message');
            document.getElementById('result-text').textContent = "å…¨å“¡ã®çµæœã‚’è¡¨ç¤ºã—ã¾ã—ãŸï¼";
            msgBox.classList.remove('hidden');
            msgBox.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        window.addEventListener('resize', () => {
            if(!document.getElementById('game-panel').classList.contains('hidden')) {
                resizeCanvas();
            }
        });

        init();

    </script>
</body>
</html>
